//Handler module for personalizing a page

const {Cc, Ci} = require('chrome')
var historyService = Cc["@mozilla.org/browser/nav-history-service;1"].getService(Ci.nsINavHistoryService);
var {LICA, create_stoplist} = require('./classifier_LICA')


function get_history() {
	//Gets the last 30 days worth of history
	//Each result is [url, accessCount]
	var options = historyService.getNewQueryOptions();
	var query = historyService.getNewQuery();
	query.beginTimeReference = query.TIME_RELATIVE_NOW;
	query.beginTime = -24 * 30 * 60 * 60 * 1000000; // 30 * 24 hours ago in microseconds
	query.endTimeReference = query.TIME_RELATIVE_NOW;
	query.endTime = 0; // now
	
	var result = historyService.executeQuery(query, options);
	var cont = result.root;
	cont.containerOpen = true;
	
	results = []
	
	for (var i = 0; i < cont.childCount; i ++) {
		var node = cont.getChild(i);
		results.push([node.uri, node.accessCount])
	}
	cont.containerOpen = false;
	
	return results
}

function clean_text(element, stoplist=false) {
	//given an html element, it tokenizes and concatenates
	//any text within, having stripped out the html tags
	var tokens = element.toLowerCase().match(/[a-z]{3,}/g) //get textual tokens
	//remove anything in the stoplist
	var cleaned = []
	for (var t of tokens) {
		if (stoplist) {
			if (stoplist.hasOwnProperty(t) === false) {
				cleaned.push(t)
			}
		}else{
			cleaned.push(t)
		}
	}
	return cleaned.join(" ")
}

function relevanceScore(interestSignal, newClassification){
	//gets a relevance score between a given interest signal
	//and some classification result
	//TODO
	
	if (interestSignal.hasOwnProperty(newClassification[0])) {
		if (interestSignal[newClassification[0]].hasOwnProperty(newClassification[1])) {
			return interestSignal[newClassification[0]][newClassification[1]]
		}else{
			return interestSignal[newClassification[0]]['__ALL']
		}
	}else{
		return 0
	}
	
	return relevance
}

function chooseMostRelevant(child_divs, interestSignal, stoplist, classify){
	//1) Iterates through a series of child divs,
	//2) classifies them
	//3) orders by similarity to the interest signal
	//4) returns the most relevant one's id
	
	//TODO Edge Case: what if nothing is relevant?
	
	let bestMatch = ""
	let bestScore = 0
	
	console.log(child_divs.length, " child divs to iterate through")
	
	for (let c in child_divs) {
		
		let child_id = child_divs[c][0]
		let child_text = child_divs[c][1]
		
		console.log("this is the child id: ", child_id)
		console.log("this is the child text", child_text)
		
		let plain_text = clean_text(child_text, stoplist=stoplist)
		console.log("About to send ", plain_text.length, " letters to the classifier")
		let classification = classify(url=false, title=plain_text)
		let similarity = relevanceScore(interestSignal, classification)
		
		if (similarity > bestScore) {
			bestScore = similarity
			bestMatch = child_id
		}
	}
	
	return bestMatch
}

function getInterestSignal(){
	//returns interest signal
	
	//interest signal is a subset of the mozcat taxonomy
	//generated by running LICA on browsing history
	
	signal = { //TODO include actual history with historyService
		"hobbies & interests": {
			"__ALL": 0.6,
			"coins":0.6
		},
		"technology & computing": {
			"__ALL": 0.4,
			"general": 0.4
		}
	}
	
	return signal
}

function process_page(containers){
	//Main handler function
	//Accepts a container/child object from personalize_worker
	//Returns a list of lists [[container_id, child_id]]
	
	console.log("Setting up classifier")
	
	var lica = new LICA(); console.log('LICA started')
	let signal = getInterestSignal(); console.log("got interest signal")
	
	console.log('Processing page...')
	
	//get containers
	let results = []
	for (let container_id of Object.keys(containers)) { //list of div containers
		console.log("Working on container: ", container_id)
		let most_relevant = chooseMostRelevant(containers[container_id], signal, stoplist=lica.stoplist, lica.classify)
		results.push([container_id, most_relevant])
	}
	
	console.log("Finished processing page content")
	
	return results
}

exports.process_page = process_page;